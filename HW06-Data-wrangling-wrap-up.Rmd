---
title: "HW06-data-wrangling-wrap-up"
author: "Rachel Lobay"
date: '2018-11-04'
output: github_document
always_allow_html: yes
---

# Table of contents

- [Part 1: Character Data Overview](#part-1-character-data-overview)
    + [14.2.5 Exercise 1: Difference between paste() and paste0()](#14.2.5-exercise-1-difference-between-paste-and-paste0)
    + [14.2.5 Exercise 2: Difference between sep and collapse arguments to str_c()](#14.2.5-exercise-2-difference-between-sep-and-collapse-arguments-to-str_c)
    + [14.2.5 Exercise 3: Write a function that turns a vector into a string](#14.2.5exercise-3-write-a-function-that-turns-a-vector-into-a-string)    
    + [14.3.3 Exercise 1: Create regular expressions to find all words](#14.3.3-exercise-1-create-regular-expressions-to-find-all-words)
 
                        
        
# Part 1: Character Data Overview

I will read and work on the exercises from the [Strings chapter of R for Data Science](https://r4ds.had.co.nz/strings.html). 

First, I will load the necessary packages for this part of the assignment.

```{r message=FALSE}
library(tidyverse)
library(stringr)
```


## 14.2.5 Exercise 1: Difference between paste() and paste0() 

Questions: 

In code that doesn’t use stringr, you’ll often see paste() and paste0(). What’s the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of NA?

Answer:

Since there are multiple questions in this exercise, we will go through each question one-by-one.

First, we will see what the difference is between paste() and paste0().

A good approach to discern the difference between paste() and paste0() is to first test them on a simple case. Hence, I will look at two strings that say "Hi" and "mom". 

We will see what the output is for paste.

```{r}
paste("hi","mom")
```
Next, we will inspect paste0.

```{r}
paste0("hi","mom")
```

Clearly, we can see that when we use the paste function on the two strings, we get a space between the strings by default. However, when we use the paste0 function, we do not get a space between the string. Hence the paste and paste0 functions serve slightly difference purposes.

Now, we will move on to see what stringr function paste() and paste0() are equivalent to.

Out of the possible stringr functions, I think that str_c() is the closest function because, as we discussed in class cm102, str_c() is used to concatenate strings. Now, out of paste() and paste0(), which is str_c() closest in function to? Let's try it out below and see!

```{r}
str_c("hi", "mom")
```
So, we get "himom" as our output without any space between the strings. Hence, str_c() is more similar to paste0() than paste().

The final question to answer is how do the functions differ in their handling of NA? 

Again, our approach to this problem will lead with an example. We shall see what happens when we use NA as an argument in each of paste(), paste0(), and str_c(). 

First, we will look at the paste function with an NA as the third argument.

```{r}
paste("hi","mom", NA)
```
It looks like with the paste function, NA is made into a string and treated as such. So, we see that, like with the strings "hi" and "mom", there is a space between the 'strings' "mom" and "NA".

Now, we will look at the paste0 function with an NA as the third argument.

```{r}
paste0("hi","mom", NA)
```

Similar to the paste function, we see that the paste0 function appears to make NA into a string and treat it as such. So, there is no space between the mom and NA 'strings'.

Finally, we will look at the str_c function with an NA as the third argument.

```{r}
str_c("hi","mom", NA)
```

When we have a NA as the third argument of str_c, we only get NA returned. So, what is happening? Based on our example, it looks like str_c puts importance on the NA. If we try to have the NA between the "hi" and "mom" strings, does the same thing happen?

```{r}
str_c("hi", NA, "mom")
```

Yes. There is just a NA returned. 

Finally, what if NA comes before our "hi" "mom" strings.

```{r}
str_c(NA, "hi", "mom")
```

Again, there is just a NA returned. 

Based on our examples, we can conclude that the str_c() function will return a NA if any argument is NA.

## 14.2.5 Exercise 2: Difference between sep and collapse arguments to str_c()

Question:

In your own words, describe the difference between the sep and collapse arguments to str_c().

Answer:

I suppose the easy (and cheap) solution would be to look up the str_c() function and reiterate what it says the arguments are in my own words... But, I will use my example then interpret appraoch to try to see the differences between the two arguments.

We shall look at the two arguments in str_c() using an example where we will concatenate strings that pertain to a few of Van Gogh's famous paintings.

If we just use the sep argument, let's see what we find.

```{r}
str_c(c("The Starry Night", "Sunflowers", "The Potato Eaters"), "Van Gogh", sep = " ")
```

So we see that we get three strings "The Starry Night Van Gogh", "Sunflowers Van Gogh", and "The Potato Eaters Van Gogh". However, let's say we want to use `sep = " by "` so that we get, for example, "The Starry Night by Van Gogh" as one of our outputs. Does that work?

```{r}
str_c(c("The Starry Night", "Sunflowers", "The Potato Eaters"), "Van Gogh", sep = " by ")
```
Yes. It does. What we can say from this is that the sep argument puts a string of the sep argument in between the string arguments. 

Now, let's look at the collapse argument. We shall start by looking at its default.

```{r}
str_c(c("The Starry Night", "Sunflowers", "The Potato Eaters"), " Van Gogh", collapse="")
```

By default we get no space between the strings. Furthermore, the output is a vector of length one with all the individual strings pasted together (as was discussed in class).

We shall try to have a comma in between each of the strings when we use the collapse argument to collapse those strings down into a vector of length one.

```{r}
str_c(c("The Starry Night", "Sunflowers", "The Potato Eaters"), " Van Gogh", collapse=", ")
```
We got what we wanted. So, it did work to use a comma as the argument of collapse. 

Now, what if we try to put a string "or" as the argument of collapse?

```{r}
str_c(c("The Starry Night", "Sunflowers", "The Potato Eaters"), " Van Gogh", collapse="or")
```
No dice. the result doesn't produce or between each of the string arguments. Rather, we get the default collapse argument, which was just all the strings pasted together in one vector of length one with no space between the strings. 

What if we now used the sep and collapse arguments together.

```{r}
str_c(c("The Starry Night", "Sunflowers", "The Potato Eaters"), " Van Gogh", sep = " by", collapse=", ")
```
The output is one vector of length one with a comma between each of the original string arguments and a string of the sep argument " by" in between each of the original string arguments.

Let's look at the big picture. What is the difference between the sep and collapse arguments of str_c())? Simply put, the sep argument puts a string of the sep argument in between the string arguments, while the collapse argument separates the elements of the vector of length one.



## 14.2.5 Exercise 3: Write a function that turns a vector into a string

Question:

Write a function that turns (e.g.) a vector c("a", "b", "c") into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2.

Answer:

We shall create a function and test it using the vector c("U", "B", "C").

The prompt wants us to handle vectors of length 0, 1, or 2. Therefore, when we design our function, we want to keep the deal with the cases of different vector lengths.

For example:
- A vector of length 0 would be the empty string "". 
- A vector of length 1 would be something like "U". 
- A vector of length 2 would be "U and B" (ie. we want to return a string of the two vector elements separated by and). 
- Finally, for a vector of length 3, we would have a string "U, B, and C" returned. 

An easy solution would be to use, cumbersome but effective, if-else statements to handle the case where the vector is less than length 2, exactly equal to length 2, and the case where the vector is greater than length 2. 

<!-- The last part under the else statement is a bit tricky to understand, so I will explain the steps. To minimize the code, I only used two lines. In the first line, I created a vector of length one of all the elements but the last element of the original vector, where each element is separated by a comma. The second line is where I simply add ", and " between the vector of length one and last element.--> 


```{r}
vector_to_string_fun <- function(x){
  # handles the cases where the vector is less than length 2
  if(length(x) < 2){
    x
  }
  # handles the cases where the vector is exactly length 2
  else if(length(x) == 2){
    x %>% 
    str_c(x[1], " and ", x[2]) # separates the two elements of the vector by " and "
  }
  else {
     # handles the cases where the vector is > than length 2
    # create a vector of length one of all the elements but the last element of the vector, where each element is separated by a comma
    str_before_last <- str_c(x[seq_len(length(x)-1)], collapse = ", ")
    # add ", and " between str_before_last and last element
    str_c(str_before_last, ", and ", x[length(x)])
  }
}
```

Now we shall test it using our ubc example.

```{r}
# Define ubc vector
ubc <- c("U", "B", "C")

vector_to_string_fun(ubc)
```

We got what we wanted - a vector of length 1 that is a string "U, B, and C".

## 14.3.3 Exercise 1: Create regular expressions to find all words

Create regular expressions to find all words that:

1.  Start with a vowel.
2.  That only contain consonants. (Hint: thinking about matching “not”-vowels.)
3.  End with `ed`, but not with `eed`.
4.  End with `ing` or `ise`.

For some background, this exerise pertains to the part of the chapter on viewing HTML rendering of expression matches for which we will use a variant of the the str_view() function. 

Answer: 
Before we get to creating the expressions, we should go over the five useful tools from the [notes](https://r4ds.had.co.nz/strings.html) corresponding to this exercise that are special patterns that match more than one character:

- `.`:  matches any character apart from a newline.
- `\d`: matches any digit.
- `\s`: matches any whitespace (e.g. space, tab, newline).
- `[abc]`: matches a, b, or c.
- `[^abc]`: matches anything except a, b, or c.

Don't forget position indicators from cm102!

- `^` corresponds to the __beginning__ of the line.
- `$` corresponds to the __end__ of the line.

And don't forget about quantifiers/repetition from cm102!

- `*` for 0 or more
- `+` for 1 or more
- `?` for 0 or 1

Also, from the [notes](https://r4ds.had.co.nz/strings.html), "You can use alternation to pick between one or more alternative patterns. For example, abc|xyz will match either "abc", or "xyz"." We can see this will come in handy for solving 4. where we want to find all words ending with `ing` or `ise`. Furthermore, "if precedence ever gets confusing, use parentheses to make it clear what you want". Meaning, like we discussed in cm102, use parentheses to indicate precedence.

Next, what function do we use str_view() or str_view_all()?

Note that str_view() shows the first match of a pattern. Therefore, we will use the str_view_all() function to show all the matches for a particular pattern. Note that I will set `match = TRUE` because then we control what is shown to see only the strings that have the pattern.

Now, we shall start to tackle 1.

1.  Find all words that start with a vowel.

Note that I set `match = TRUE` because then we see only strings that have the pattern and not all of them. From our above tool set, we can see that we want to match the vowels (including y). So we use, [aeiouy]. Additionall, since we want the words that START with a vowel, we use the position indicator ^. Hence, the solution is:

```{r}
words %>% 
  str_view_all("^[aeouiy]", match = TRUE)
```

We can see this appears to produce the correct output for words that start with a vowel (although there are a lot of matches to go through).

2.  Find all words only contain consonants. (Hint: thinking about matching “not”-vowels.)

The hint basically gives us the key to the solution. From our tool kit above, we see `[^abc]`: matches anything except a, b, or c. Hence, we will use [^aeouiy]. Next, we want to consider the words begin with a vowel, continue without a vowel, and end without a vowel. So, we use the beginning indicator ^, * that indicates 0 or more, and finish off with the ending position indicator $.

```{r}
words %>% 
str_view_all("^[^aeouiy]*$", match = TRUE)
```

We can see this appears to produce the correct output for words that only contain consonants.

3.  Find all words that end with `ed`, but not with `eed`.

So, we want all words that end with `ed`. We can use the ending position indicator `$` to achieve that. So we have `ed`. Next, we don't want the words that end with `eed`. To do that, we can refer to the pattern `[^abc]`: matches anything except a, b, or c. So, all together, the pattern is `[^e]ed$`. Let's see if that works...

```{r}
words %>% 
str_view_all("[^e]ed$", match = TRUE)
```

Looks like this appears to produce the correct output for words that end with `ed`, but not with `eed`.

4.  Find all words that end with `ing` or `ise`.

This was the problem that clearly used the alternation symbol | (which is basically "or"). Now, since ing and ise overlap with the i character, we will use parentheses like did with the beer or bear example in cm102, which I will post below:

```{r}
# first define function str_view_all_match
str_view_all_match <- function(countries, pattern) {
    str_view_all(countries, pattern, match=TRUE)
}
```

Beer or bear?

```{r}
c("bear", "beer", "bar") %>% 
    str_view_all_match(pattern = "be(e|a)r")
```

In that example, we used be(e|a)r to say that the letter after be could either be an e or a and then we finished off that word with r. Hence, we got beer or bear as the output.

Similarly, like I said above, ing and ise overlap with the i character, so we can do i(ng|se). And we want all words ending with ing or ise, so we also use the ending position indicator `$` to get i(ng|se)$. Let's see the code in full for this question:

```{r}
words %>% 
str_view_all("i(ng|se)$", match = TRUE)
```

Again, we get that it appears to produce the correct output, giving us the words that end with `ing` or `ise`. So, our winning streak continues. 

## 14.4.3.1 Exercise # 2 

Question: 

From the Harvard sentences data, extract:

1) The first word from each sentence.
2) All words ending in ing.
3) All plurals.


## 14.7.1 Exercise # 1 on Stringi package functions

Question:

Find the stringi functions that:

1) Count the number of words.
2) Find duplicated strings.
3) Generate random text.

## 14.7.2 Exercise # 2 on Stringi package functions

Question: 

How do you control the language that stri_sort() uses for sorting?